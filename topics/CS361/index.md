<small>[Return Home](../../README.md)</small>

# CS 361 Software Engineering I

- [Microservices](microservices.md)
- [Scrum](scrum.md)
<!-- - - [Week 4](week4.md)
- [Week 5](week5.md)
- [Week 6](week6.md)
- [Week 7](week7.md)
- [Week 8](week8.md) -->

| Keyword                | Definition                                                                                                                                                           |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Software Engineering` | Software engineering is the art and science of using different methods to efficiently create extensible, sustainable programs that solve problems people care about. |
| `Scrum`                | A set of methods for executing the Agile philosophy                                                                                                                  |

## Software Development Lifecycle (SDLC)

- The way a softeare project proceeds through these stages: Requirements, Design, Implementation, Testing, and Maintenance.

### Waterfall

<img src="./../../images/waterfall.jpg" height="400px">

### Agile

<img src="./../../images/agile.jpg" height="400px">

- Short and numerous dev cycles
- Releases are frequent and incremental.
- [Agile Manifesto](https://web.archive.org/web/20210412193442/http://agilemanifesto.org/iso/en/principles.html)

What people that use agile value:

- Individuals and interactions over processes and tools
- Working software over comprehensive documentation
- Customer collaboration over contract negotiation
- Responding to change over following a plan

<br>

## Cognitive style heuristics
LINKS:

- [GenerMag Project]()

Eight priniciples of interaction designed around how different people use software in different ways.

Cognitive problem solving facets:

- User motivation for using the softewer (task completion vs interest)
- Their information processing style
- Their computer self-efficacy (low vs. high)
- Their attitude toward risk (risk-averse vs. risk-tolerant)
- Their style of learning new software (by process vs. by tinkering)

### The 8 principles of interaction
1. Explain the benefits of using new and existing features
2. Explain the costs of using new and existing features
3. Let users gather as much info as they want and no more than they want
4. Keep familiar features available
5. Make undo/redo and backtracking available
6. Provide an explicit path through the task
7. Provide ways to try out different approaches
8. Encourage tinkerers to tinker mindfully 
   * E.g. Add confirm buttons